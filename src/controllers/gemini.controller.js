// This controller receives a natural language prompt from the user
// and returns a response generated by Gemini using school data

import axios from 'axios';
import { Class } from '../models/class.model.js';
import { Attendance } from '../models/attendance.model.js';
import { Marks } from '../models/marks.model.js';
import { ApiError } from '../utils/ApiError.js';
import { ApiResponse } from '../utils/ApiResponse.js'
import { Voucher } from '../models/voucher.model.js';

export const adminAi = async (req, res) => {
  try {
    const instituteId = req.user._id;
    const { prompt: userPrompt } = req.body;

    // 1. Keyword check to decide which data to fetch
    const needsClassData = /\b(class|teacher|subject|student|institute|school)\b/i.test(userPrompt);
    const needsMarks = /\b(marks?|grades?|scores?)\b/i.test(userPrompt);
    const needsAttendance = /\b(attendance|present|absent|leave)\b/i.test(userPrompt);
    const needsVouchers = /\b(voucher|vouchers|fee|payment|bill)\b/i.test(userPrompt);

    let classInfo = '', marksData = '', attendanceData = '', voucherData = '';
    let instituteInfo = '';

    // 2. Fetch class data if required
    if (needsClassData) {
      const classData = await Class.find({ instituteId })
        .populate('students', '-_id -password -logo -studentClass -section -studentId -createdAt -updatedAt -__v')
        .populate('classTeacher', '-_id -password -logo -createdAt -updatedAt -__v -classTeacherOf')
        .populate([
          {
            path: 'subjects',
            select: '-_id -classTitle -section -createdAt -updatedAt -__v',
            populate: [{ path: 'subjectTeacher', select: 'name teacherId -_id' }],
          },
        ])
        .populate('instituteId', '-_id -password -logo -createdAt -updatedAt -__v');

      classInfo = classData.map(cls => {
        const classTeacher = cls.classTeacher;
        const classTeacherInfo = classTeacher ? `
  Class Teacher: ${classTeacher.name} (${classTeacher.teacherId})
  Department: ${classTeacher.department || 'N/A'}
  Email: ${classTeacher.email || 'N/A'}
  Phone: ${classTeacher.phoneNumber || 'N/A'}
  DOB: ${new Date(classTeacher.dateOfBirth).toDateString()}
  Address: ${classTeacher.address || 'N/A'}
  Qualifications: ${(classTeacher.qualifications || []).join(", ") || 'N/A'}
  Blood Group: ${classTeacher.bloodGroup || 'N/A'}
  Nationality: ${classTeacher.nationality || 'N/A'}
  Emergency Contact: ${classTeacher.emergencyContact || 'N/A'}
        `.trim() : 'Class Teacher: N/A';

        const institute = cls.instituteId;
        instituteInfo = institute ? `This Institute Name: ${institute.instituteName}, Institute Email: ${institute.email}` : 'Institute: N/A';

        const subjectsInfo = cls.subjects.map(sub => {
          const teacher = sub.subjectTeacher;
          return `  - ${sub.subjectName} (Teacher: ${teacher?.name || 'N/A'} - ${teacher?.teacherId || 'N/A'})`;
        }).join("\n");

        const studentsInfo = cls.students.map(stu =>
          `  - ${stu.name} (${stu.rollNumber})`
        ).join("\n");

        return `
Class: ${cls.classTitle}${cls.section}
${classTeacherInfo}
Subjects:
${subjectsInfo}
Students:
${studentsInfo}
        `.trim();
      }).join("\n\n");
    }

    // 3. Fetch marks if required
    if (needsMarks) {
      const marksRecords = await Marks.find({ instituteId })
        .populate('student', 'name rollNumber -_id')
        .populate('subjectTeacher', '-_id name teacherId');

      marksData = marksRecords.map(m =>
        `${m.student.name} scored ${m.obtainedMarks}/${m.totalMarks} and Grade ${m.grade} in ${m.subject} in ${m.assessmentType.toLowerCase()}`
      ).join("\n") || 'No marks records found';
    }

    // 4. Fetch attendance if required
    if (needsAttendance) {
      const attendanceRecords = await Attendance.find({ instituteId })
        .populate('students.studentId', 'name rollNumber');

      attendanceData = attendanceRecords.map(record => {
        const entries = record.students.map(s =>
          `  - ${s.studentId?.name} (${s.studentId?.rollNumber}) was ${s?.status}`
        ).join("\n");
        return `Attendance:${entries}`;
      }).join("\n\n") || 'No attendance records found';
    }

    // 5. Fetch voucher data if required
    if (needsVouchers) {
      const voucherRecords = await Voucher.find({ instituteId })
        .populate('student', 'name rollNumber -_id')
        .select('amount month year dueDate status voucherId -_id')
        .sort({ year: -1, month: -1 }); // Sort by most recent

      voucherData = voucherRecords
        .map(v =>
          `Voucher ID: ${v.voucherId}, Student: ${v.student?.name || 'N/A'} (${v.student?.rollNumber || 'N/A'}), Amount: ${v.amount}, Month: ${v.month} ${v.year}, Due Date: ${new Date(v.dueDate).toDateString()}, Status: ${v.status}`
        )
        .join("\n") || 'No fee voucher records found';
    }

    // 6. Final payload
    const allInfo = `
Prompt: ${userPrompt}

${needsClassData ? `Class Information:\n${classInfo}\n` : ''}
${needsMarks ? `Marks:\n${marksData}\n` : ''}
${needsAttendance ? `Attendance Records:\n${attendanceData}\n` : ''}
${needsVouchers ? `Fee Vouchers:\n${voucherData}\n` : ''}
${instituteInfo ? `Institute Info:\n${instituteInfo}\n` : ''}
    `.trim();

    // 7. Send to Gemini
    const geminiRes = await axios.post(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${process.env.GEMINI_API_KEY}`,
      {
        contents: [
          {
            parts: [{ text: allInfo }]
          }
        ]
      }
    );

    res.json({
      prompt: userPrompt,
      result: geminiRes.data.candidates?.[0]?.content?.parts?.[0]?.text || 'No result from Gemini'
    });

  } catch (error) {
    console.error('Gemini API Error:', error);
    res.status(500).json({ error: 'Something went wrong with Gemini request' });
  }
};

export const teacherAi = async (req, res) => {
  const {
    _id: teacherId,
    name: teacherName,
    email: teacherEmail,
    teacherId: teacherCode,
    department,
    qualifications,
    phoneNumber,
    dateOfBirth,
    address,
    emergencyContact,
    bloodGroup,
    nationality,
    logo: teacherLogo,
    classTeacherOf,  // This contains the class details where teacher is class teacher
    instituteId: institute
  } = req.user;

  const { prompt: userPrompt } = req.body;

  // Validate prompt and data
  const sanitizedPrompt = userPrompt?.trim().replace(/[\n\r\t]+/g, ' ');
  if (!sanitizedPrompt) throw new ApiError(400, 'Prompt is required');
  if (!institute) throw new ApiError(400, 'Institute information is missing');

  // Check for institute name query
  if (/\b(name of.*institute|institute.*name|what.*institute)\b/i.test(sanitizedPrompt)) {
    return res.status(200).json(
      new ApiResponse(
        200,
        {
          prompt: sanitizedPrompt,
          teacher: {
            id: teacherId,
            name: teacherName,
            email: teacherEmail,
            teacherCode,
            department
          },
          institute: {
            id: institute._id,
            name: institute.instituteName,
            email: institute.email
          },
          result: `The institute is ${institute.instituteName} (Email: ${institute.email}).`
        },
        'Institute name query processed successfully'
      )
    );
  }

  // Prepare teacher profile information
  const teacherProfile = `
Teacher Profile:
- Name: ${teacherName}
- Teacher ID: ${teacherCode}
- Email: ${teacherEmail}
- Department: ${department}
- Qualifications: ${qualifications?.join(', ') || 'N/A'}
- Phone: ${phoneNumber || 'N/A'}
- Date of Birth: ${dateOfBirth ? new Date(dateOfBirth).toLocaleDateString() : 'N/A'}
- Address: ${address || 'N/A'}
- Emergency Contact: ${emergencyContact || 'N/A'}
- Blood Group: ${bloodGroup || 'N/A'}
- Nationality: ${nationality || 'N/A'}
  `.trim();

  // Prepare class information if teacher is a class teacher
  let classInfo = '';
  let studentsInfo = '';
  let subjectsInfo = '';

  if (classTeacherOf) {
    const { classTitle, section, students, subjects } = classTeacherOf;

    // Format students information
    studentsInfo = students.map(student => {
      return `
- ${student.name} (Roll #: ${student.rollNumber || 'N/A'})
  Email: ${student.email || 'N/A'}
  Date of Birth: ${student.dateOfBirth ? new Date(student.dateOfBirth).toLocaleDateString() : 'N/A'}
  Address: ${student.address || 'N/A'}
  Emergency Contact: ${student.emergencyContact || 'N/A'}
  Blood Group: ${student.bloodGroup || 'N/A'}
  Nationality: ${student.nationality || 'N/A'}
      `.trim();
    }).join('\n');

    // Format subjects information
    subjectsInfo = subjects.map(subject => {
      const teacher = subject.subjectTeacher;
      return `
- ${subject.subjectName}
  Teacher: ${teacher?.name || 'N/A'} (${teacher?.email || 'N/A'})
  Department: ${teacher?.department || 'N/A'}
      `.trim();
    }).join('\n');

    classInfo = `
Class Teacher of: ${classTitle}-${section}

Students (${students.length}):
${studentsInfo}

Subjects:
${subjectsInfo}
    `.trim();
  }

  // Check if teacher teaches any subjects (even if not class teacher)
  let teachingSubjectsInfo = '';
  const teachingSubjects = req.user.subjects || []; // Subjects where this teacher is subject teacher
  if (teachingSubjects.length) {
    teachingSubjectsInfo = teachingSubjects.map(subject => {
      return `
- ${subject.subjectName} (Class: ${subject.classTitle}-${subject.section})
      `.trim();
    }).join('\n');
  }

  // Check for marks related queries
  let marksData = '';
  if (/\b(marks?|grades?|exam|test)\b/i.test(sanitizedPrompt)) {
    // Get marks for subjects taught by this teacher (both as class teacher and subject teacher)
    const subjectNames = [
      ...(classTeacherOf?.subjects?.map(s => s.subjectName) || []),
      ...(teachingSubjects.map(s => s.subjectName) || [])
    ];

    if (subjectNames.length) {
      const marks = await Marks.find({
        instituteId: institute._id,
        classTitle: classTeacherOf.classTitle,
        section: classTeacherOf.section
      })
        .populate({
          path: 'student',
          select: 'name rollNumber'
        })
        .sort({ date: -1 })
        .limit(50) // Recent 50 records
        .lean();

      if (marks.length) {
        // Group by subject
        const marksBySubject = marks.reduce((acc, mark) => {
          if (!acc[mark.subject]) {
            acc[mark.subject] = [];
          }
          acc[mark.subject].push(mark);
          return acc;
        }, {});

        marksData = Object.entries(marksBySubject).map(([subject, records]) => {
          const subjectMarks = records.map(record => {
            return `  - ${record.student.name} (Roll #: ${record.student.rollNumber || 'N/A'}): ${record.obtainedMarks}/${record.totalMarks} (${record.assessmentType}) - Date: ${record.createdAt ? new Date(record.createdAt).toLocaleDateString() : 'N/A'}`;
          }).join('\n');

          return `
${subject}:
${subjectMarks}
          `.trim();
        }).join('\n\n');
      } else {
        marksData = 'No marks records found for your subjects';
      }
    } else {
      marksData = 'You are not assigned to any subjects';
    }
  }

  // Check for attendance related queries
  let attendanceData = '';
  if (/\b(attendance|present|absent)\b/i.test(sanitizedPrompt) && classTeacherOf) {
    // Get attendance for the class where teacher is class teacher
    const attendance = await Attendance.find({
      instituteId: institute._id,
      classId: classTeacherOf._id
    })
      .sort({ date: -1 })
      .limit(30) // Last 30 records
      .lean();

    if (attendance.length) {
      const presentCounts = {};
      const studentNames = {};

      // Initialize counts and names
      classTeacherOf.students.forEach(student => {
        presentCounts[student._id] = 0;
        studentNames[student._id] = student.name;
      });

      // Calculate present days for each student
      attendance.forEach(record => {
        record.students?.forEach(studentRecord => {
          if (studentRecord.status === 'present') {
            presentCounts[studentRecord.studentId]++;
          }
        });
      });

      // Format attendance summary
      const attendanceSummary = Object.entries(presentCounts).map(([studentId, presentDays]) => {
        const totalDays = attendance.length;
        const absentDays = totalDays - presentDays;
        return `- ${studentNames[studentId]}: ${presentDays}/${totalDays} (${Math.round((presentDays / totalDays) * 100)}`;
      }).join('\n');

      // Get recent records
      const recentRecords = attendance.slice(0, 5).map(record => {
        const dateStr = new Date(record.date).toLocaleDateString();
        const presentStudents = record.students?.filter(s => s.status === 'present').length || 0;
        const totalStudents = classTeacherOf.students.length;
        return `- ${dateStr}: ${presentStudents}/${totalStudents} present`;
      }).join('\n');

      attendanceData = `Class Attendance Summary:
Total Days Recorded: ${attendance.length}

Student Attendance Rates:
${attendanceSummary}

Recent Attendance Records:
${recentRecords}`;
    } else {
      attendanceData = 'No attendance records found for your class';
    }
  }

  // Prepare context for Gemini
  const context = `
Teacher Information:
${teacherProfile}

${classTeacherOf ? `
Class Teacher Information:
${classInfo}
` : ''}

${teachingSubjectsInfo ? `
Subjects You Teach:
${teachingSubjectsInfo}
` : ''}

${marksData ? `
Marks Information:
${marksData}
` : ''}

${attendanceData ? `
Attendance Information:
${attendanceData}
` : ''}

Institute Information:
- Name: ${institute.instituteName}
- Email: ${institute.email}

User Question: ${sanitizedPrompt}
  `.trim();

  // Call Gemini API
  const geminiRes = await axios.post(
    `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${process.env.GEMINI_API_KEY}`,
    { contents: [{ parts: [{ text: context }] }] }
  );

  const geminiResult = geminiRes.data?.candidates?.[0]?.content?.parts?.[0]?.text || 'No response from AI';

  return res.status(200).json(
    new ApiResponse(
      200,
      {
        prompt: sanitizedPrompt,
        teacher: {
          id: teacherId,
          name: teacherName,
          email: teacherEmail,
          teacherCode,
          department,
          isClassTeacher: !!classTeacherOf,
          classTeacherOf: classTeacherOf ? {
            class: `${classTeacherOf.classTitle}-${classTeacherOf.section}`,
            studentsCount: classTeacherOf.students.length,
            subjectsCount: classTeacherOf.subjects.length
          } : null,
          teachingSubjects: teachingSubjects.map(sub => ({
            name: sub.subjectName,
            class: `${sub.classTitle}-${sub.section}`
          }))
        },
        institute: {
          id: institute._id,
          name: institute.instituteName,
          email: institute.email
        },
        result: geminiResult
      },
      'Query processed successfully'
    )
  );
};

export const studentAi = async (req, res) => {
  const studentId = req.user._id;
  const instituteId = req.user.instituteId._id;
  const { instituteName, email } = req.user.instituteId;

  const { prompt: userPrompt } = req.body;

  if (!userPrompt || typeof userPrompt !== 'string') {
    throw new ApiError(400, 'Prompt is required and must be a string');
  }

  // 1. Keyword check to decide which data to fetch
  const needsClassData = /\b(class|teacher|subject)\b/i.test(userPrompt);
  const needsMarks = /\b(marks?|grades?|scores?)\b/i.test(userPrompt);
  const needsAttendance = /\b(attendance|present|absent|leave)\b/i.test(userPrompt);
  const needsVouchers = /\b(voucher|fee|payment|bill)\b/i.test(userPrompt);

  let classInfo = '';
  let marksData = '';
  let attendanceData = '';
  let voucherData = '';

  // 2. Fetch class data if required
  if (needsClassData) {
    const classData = await Class.findOne({
      instituteId,
      students: studentId,
    })
      .populate('classTeacher', 'name teacherId department email phoneNumber -_id')
      .populate({
        path: 'subjects',
        select: 'subjectName -_id',
        populate: { path: 'subjectTeacher', select: 'name teacherId -_id' },
      })
      .select('classTitle section -_id');

    if (classData) {
      const classTeacher = classData.classTeacher || {};
      const subjectsInfo = classData.subjects
        .map(
          (sub) =>
            `  - ${sub.subjectName} (Teacher: ${sub.subjectTeacher?.name || 'N/A'} - ${sub.subjectTeacher?.teacherId || 'N/A'})`
        )
        .join('\n');

      classInfo = `
Class: ${classData.classTitle}${classData.section}
Class Teacher: ${classTeacher.name || 'N/A'} (${classTeacher.teacherId || 'N/A'})
Teacher Contact: ${classTeacher.email || 'N/A'}, ${classTeacher.phoneNumber || 'N/A'}
Subjects:
${subjectsInfo}
        `.trim();
    } else {
      classInfo = 'No class information found for this student.';
    }
  }

  // 3. Fetch marks if required
  if (needsMarks) {
    const marksRecords = await Marks.find({
      instituteId,
      student: studentId,
    })
      .populate('subjectTeacher', 'name teacherId -_id')
      .select('subject obtainedMarks totalMarks grade assessmentType -_id');

    marksData = marksRecords
      .map(
        (m) =>
          `Scored ${m.obtainedMarks}/${m.totalMarks} Grade:(${m.grade}) in ${m.subject} (${m.assessmentType.toLowerCase()})`
      )
      .join('\n') || 'No marks recorded for this student.';
  }

  // 4. Fetch attendance if required
  if (needsAttendance) {
    const attendanceRecords = await Attendance.find({
      instituteId,
      'students.studentId': studentId,
    }).select('date students -_id');

    attendanceData = attendanceRecords
      .map((record) => {
        const studentEntry = record.students.find((s) =>
          s.studentId.equals(studentId)
        );
        return `Date: ${new Date(record.date).toDateString()} - Status: ${studentEntry?.status || 'N/A'}`;
      })
      .join('\n') || 'No attendance records found for this student.';
  }

  // 5. Fetch all voucher data if required
  if (needsVouchers) {
    const voucherRecords = await Voucher.find({
      instituteId,
      student: studentId,
    })
      .select('amount month year dueDate status voucherId -_id')
      .sort({ year: -1, month: -1 }); // Sort by most recent year and month

    voucherData = voucherRecords
      .map(
        (v) =>
          `Voucher ID: ${v.voucherId}, Amount: ${v.amount}, Month: ${v.month} ${v.year}, Due Date: ${new Date(v.dueDate).toDateString()}, Status: ${v.status}`
      )
      .join('\n') || 'No fee voucher records found for this student.';
  }

  // 6. Final payload for Gemini
  const allInfo = `
Prompt: ${userPrompt}

${needsClassData ? `Class Information:\n${classInfo}\n` : ''}
${needsMarks ? `Marks:\n${marksData}\n` : ''}
${needsAttendance ? `Attendance Records:\n${attendanceData}\n` : ''}
${needsVouchers ? `Fee Vouchers:\n${voucherData}\n` : ''}
Institute: ${instituteName} (${email})
    `.trim();

  // 7. Send to Gemini API
  const geminiRes = await axios.post(
    `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${process.env.GEMINI_API_KEY}`,
    {
      contents: [{ parts: [{ text: allInfo }] }],
    }
  );

  // 8. Send response
  res.status(200).json(
    new ApiResponse(
      200,
      {
        prompt: userPrompt,
        result:
          geminiRes.data.candidates?.[0]?.content?.parts?.[0]?.text ||
          'No result from Gemini',
      },
      'Query processed successfully'
    )
  );
};

export const parentAi = async (req, res) => {
  const {
    _id: parentId,
    name: parentName,
    email: parentEmail,
    phoneNumber: parentPhone,
    childrens: children,
    instituteId: institute
  } = req.user;

  const { prompt: userPrompt } = req.body;

  // Validate prompt and data
  const sanitizedPrompt = userPrompt?.trim().replace(/[\n\r\t]+/g, ' ');
  if (!sanitizedPrompt) throw new ApiError(400, 'Prompt is required');
  if (!children?.length) throw new ApiError(400, 'No children associated with this parent');
  if (!institute) throw new ApiError(400, 'Institute information is missing');

  // Check for institute name query
  if (/\b(name of.*institute|institute.*name|what.*institute)\b/i.test(sanitizedPrompt)) {
    return res.status(200).json(
      new ApiResponse(
        200,
        {
          prompt: sanitizedPrompt,
          parent: {
            id: parentId,
            name: parentName,
            email: parentEmail,
            phone: parentPhone
          },
          institute: {
            id: institute._id,
            name: institute.instituteName,
            email: institute.email
          },
          children: children.map(child => ({
            id: child._id,
            name: child.name,
            result: `The institute is ${institute.instituteName} (Email: ${institute.email}).`
          })),
          requestedClasses: []
        },
        'Institute name query processed successfully'
      )
    );
  }

  // Extract child classes and sections
  const childClasses = children.map(child => ({
    classNum: child.studentClass,
    section: child.section
  }));

  // Fetch classes with detailed population
  const classes = await Class.find({
    instituteId: institute._id,
    $or: childClasses.map(cls => ({
      classTitle: cls.classNum.toString(),
      section: cls.section
    }))
  })
    .populate({
      path: 'classTeacher',
      select: 'name teacherId email department qualifications phoneNumber dateOfBirth address emergencyContact bloodGroup nationality logo'
    })
    .populate({
      path: 'students',
      select: 'name email rollNumber dateOfBirth address emergencyContact bloodGroup nationality logo'
    })
    .populate({
      path: 'subjects',
      select: 'subjectName',
      populate: {
        path: 'subjectTeacher',
        select: 'name teacherId email department'
      }
    })
    .lean();

  // Process each child's data
  const childrenData = await Promise.all(children.map(async child => {
    const childClass = classes.find(c =>
      c.classTitle == child.studentClass.toString() &&
      c.section == child.section
    );

    let classInfo = '';
    if (childClass) {
      // Format subjects with their teachers
      const subjectsInfo = childClass.subjects.map(sub => {
        const teacher = sub.subjectTeacher;
        return `- ${sub.subjectName} (Teacher: ${teacher?.name || 'N/A'} - ${teacher?.email || 'N/A'})`;
      }).join('\n');

      // Format classmates information
      const classmates = childClass.students
        .filter(s => s._id.toString() !== child._id.toString())
        .map(s => `- ${s.name} (Roll #: ${s.rollNumber || 'N/A'})`)
        .join('\n');

      const teacher = childClass.classTeacher;

      classInfo = `
Student: ${child.name} (${child.email || 'No email'})
Class: ${childClass.classTitle}-${childClass.section}

Class Teacher Details:
- Name: ${teacher?.name || 'N/A'}
- ID: ${teacher?.teacherId || 'N/A'}
- Email: ${teacher?.email || 'N/A'}
- Department: ${teacher?.department || 'N/A'}
- Phone: ${teacher?.phoneNumber || 'N/A'}
- Date of Birth: ${teacher?.dateOfBirth ? new Date(teacher.dateOfBirth).toLocaleDateString() : 'N/A'}
- Address: ${teacher?.address || 'N/A'}
- Qualifications: ${teacher?.qualifications?.join(', ') || 'N/A'}
- Blood Group: ${teacher?.bloodGroup || 'N/A'}
- Nationality: ${teacher?.nationality || 'N/A'}
- Emergency Contact: ${teacher?.emergencyContact || 'N/A'}

Subjects:
${subjectsInfo}

Classmates:
${classmates || 'No classmates information available'}
      `.trim();
    }

    // Fetch marks with subject teacher details
    let marksData = '';
    if (/\b(marks?|grades?|exam|test)\b/i.test(sanitizedPrompt)) {
      const marks = await Marks.find({
        instituteId: institute._id,
        student: child._id
      })
        .populate({
          path: 'subjectTeacher',
          select: 'name email department'
        })
        .lean();

      if (marks.length) {
        marksData = marks.map(m => {
          const teacher = m.subjectTeacher;
          return `${m.subject}: ${m.obtainedMarks}/${m.totalMarks} (${m.grade}) (${m.assessmentType})
          - Teacher: ${teacher?.name || 'N/A'} (${teacher?.email || 'N/A'}) 
          - Date: ${m.date ? new Date(m.date).toLocaleDateString() : 'N/A'}`;
        }).join('\n\n');
      } else {
        marksData = 'No marks records found';
      }
    }

    // Fetch attendance data
    let attendanceData = '';
    if (/\b(attendance|present|absent)\b/i.test(sanitizedPrompt)) {
      const attendance = await Attendance.find({
        instituteId: institute._id,
        'students.studentId': child._id
      })
        .sort({ date: -1 })
        .limit(30) // Last 30 records
        .lean();

      if (attendance.length) {
        const presentDays = attendance.filter(a =>
          a.students?.some(s => s.studentId.equals(child._id) && s.status === 'present')
        ).length;

        const recentRecords = attendance.slice(0, 5).map(a => {
          const studentEntry = a.students.find(s => s.studentId.equals(child._id));
          return `- ${new Date(a.date).toLocaleDateString()}: ${studentEntry?.status || 'N/A'}`;
        }).join('\n');

        attendanceData = `Attendance Summary:
- Total Days: ${attendance.length}
- Present: ${presentDays}
- Absent: ${attendance.length - presentDays}
- Attendance Rate: ${Math.round((presentDays / attendance.length) * 100)}%

Recent Records:
${recentRecords}`;
      } else {
        attendanceData = 'No attendance records found';
      }
    }

    // Fetch voucher data
    let voucherData = '';
    if (/\b(voucher|fee|payment|bill)\b/i.test(sanitizedPrompt)) {
      const vouchers = await Voucher.find({
        instituteId: institute._id,
        student: child._id
      })
        .select('amount month year dueDate status voucherId -_id')
        .sort({ year: -1, month: -1 }) // Sort by most recent
        .lean();

      if (vouchers.length) {
        voucherData = vouchers
          .map(v =>
            `Voucher ID: ${v.voucherId}, Amount: ${v.amount}, Month: ${v.month} ${v.year}, Due Date: ${new Date(v.dueDate).toDateString()}, Status: ${v.status}`
          )
          .join('\n');
      } else {
        voucherData = 'No fee voucher records found';
      }
    }

    return {
      id: child._id,
      name: child.name,
      classInfo: classInfo || 'No class information found',
      marksData: marksData || 'No marks data available',
      attendanceData: attendanceData || 'No attendance data available',
      voucherData: voucherData || 'No voucher data available'
    };
  }));

  // Prepare context for Gemini
  const context = `
Parent Information:
- Name: ${parentName}
- Email: ${parentEmail}
- Phone: ${parentPhone}

Institute Information:
- Name: ${institute.instituteName}
- Email: ${institute.email}

Children Information:
${childrenData.map(child => `
${child.name}:
${child.classInfo}
${child.marksData}
${child.attendanceData}
${child.voucherData}
`).join('\n')}

User Question: ${sanitizedPrompt}
  `.trim();

  // Call Gemini API
  const geminiRes = await axios.post(
    `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${process.env.GEMINI_API_KEY}`,
    { contents: [{ parts: [{ text: context }] }] }
  );

  const geminiResult = geminiRes.data?.candidates?.[0]?.content?.parts?.[0]?.text || 'No response from AI';

  return res.status(200).json(
    new ApiResponse(
      200,
      {
        prompt: sanitizedPrompt,
        parent: {
          id: parentId,
          name: parentName,
          email: parentEmail,
          phone: parentPhone
        },
        institute: {
          id: institute._id,
          name: institute.instituteName,
          email: institute.email
        },
        children: childrenData.map(child => ({
          id: child.id,
          name: child.name,
          result: geminiResult
        })),
        requestedClasses: childClasses.map(c => `${c.classNum}${c.section}`)
      },
      'Query processed successfully'
    )
  );
};


